// database entry format:


//////////////////////
// KEY (32bit) 		//	
//////////////////////
// Llink 			//
//////////////////////
// Rlink 			//
//////////////////////
// Data pointer     //
//////////////////////

#include allocation.cll


void main()
	malloc_init();
end;
 
//____________________________________ DICT TREE EDITING ALGORITHMS _____________________________________________

void editDict(int key, @int dataPTR,@int dict)
	if (key == dict[0]) then //needs to change dict
		dict[3] = dataPTR;	
	else
		if (key>dict[0]) then
			if (dict[2]) then editDict(key,dataPTR,dict[2]); //if there is a node to the right, try to add relative to it
			else dict[2] = createNewTreeNode(key,0,0,dataPTR); //otherwise fit in the new node here
			endif;
		else
			if (dict[1]) then editDict(key,dataPTR,dict[1]); //if there is a node to the left, try to add relative to it
			else dict[1] = createNewTreeNode(key,0,0,dataPTR); //otherwise fit in the new node here
			endif;
		endif;	 
	endif;
end;


@int findKey(int key, @int dict)
	//binary searchon tree
	if (not(dict)) then return 0; endif; //failure if no key of correct address
	if (key == dict[0]) then return dict[3]; endif; 		//if correct key then return address of data
	if (key>dict[0]) then return findKey(key,dict[2]); endif;
	return findKey(key,dict[1]);
end;

@int createNewTreeNode(int key,@int Llink,@int Rlink,@int dataPTR)
	@int return_value =  malloc(4);
	//creates a tree node
	return_value[0] = key;
	return_value[1] = Llink;
	return_value[2] = Rlink;
	return_value[3] = dataPTR;
	return return_value;
end;



void reBalanceDictTree(@int dict)
	@int top = sortTree(dict);  //turns tree into a doubly linked circular list with a pointer to the top element
	int length = getListLength(top);
	return createBalancedTree(top,length)
	//////////////////////////////////////////
	// FINISH ME PLZ 						//
	//////////////////////////////////////////
end;

@int createBalancedTree(@int node,length)
		///////////////////////////////////////////////////////////////
		// USING JOHN LATHAM's ALGORITHM, REWRITTEN FOR LINKED LISTS //
		///////////////////////////////////////////////////////////////
end;


@int sortTree(@int node)
	if (node[1]) then
		if (node[2]) then //both
			node[1] = sortTree(node[1]);
			@int top = sortTree(node[2]); //top is the very top end of the tree
			node[2] = top[2];
			@int bottom = node[1];
			bottom = bottom[2]; 		//bottom is the right of top(node[1])

			bottom[1] = top;
			top[2] = bottom;  //adds circular pointers

			@int temp = node[2]; 		//sets the links on the nodes left and right of central node
			temp[1] = node;

			temp = node[1];
			temp[2] = node;

		else 				//just left
			top = node;
			temp = node[1];
			node[2] = temp[2];
			bottom = node[2];
			bottom[1] = node;
			temp[2] = node;

		endif;
	else
		if (node[2]) then //just right
			node[2] = sortTree(node[2]);
			temp = node[2];
			top = temp[1];
			temp[1] = node;
			node[1] = top;
			top[2] = node;
		else  //neither
			top = node;
			node[1] = node;
			node[2] = node;
			endif;
	endif;
	return top;
end;


// _____________________________ HASHING ALGORITHMS _________________________________

int simpleHash(@char str)
//SDBM  hash function
        int hash = 0;
        char c;
        int i = 0;
        while (str[i]) do
            hash = c + (hash << 6) + (hash << 16) - hash;
        	i = i + 1;
        loop;
        return hash;
end;

////////////////////////////////////////////////////////////////////////////////////////////
// 					structure of tree is nodes of the form:
// 					--------------------------------
// 					| KeyOfNode (32bit int)			|
//					--------------------------------
// 					| Left node ptr (smaller key)	|
// 					--------------------------------
// 					| Right node ptr (larger key) 	|
// 					--------------------------------
// 					| Data Entry ptr  				|
// 					________________________________
//
// 					End node ptrs are nullified to 0
//
// 					Structure of a data entry
// 					
// 					---------------------------------
// 					| Key string pointer 			|   - points to a copy of the key string for this entry 
// 					---------------------------------  
// 					| Data Ptr 						| 	- points to the data of this entry
// 					--------------------------------- 
// 					| Collision link ptr 			| 	- points to the next entry (in event of collision)
// 					---------------------------------
//
//
//
//
//


//_________________________________________ DICT SPECIFiC FUNCTIONS ______________________________

void insertToDict(@int dict, @char keystring, int dataPTR)
	//generates a dictionary entry corresponding to the tree string
	
	int key = simpleHash(keystring);
	entryAddress = findKey(key,dict); //gets address of a data ptr
	if (entryAddress) then
		if (checkKey(entryAddress[0],keystring)) then 
			//if the same, then just  change dict pointer
			entryAddress[1] = dataPTR;
		else //need to add to linked list
			while(entryAddress[2])do
				entryAddress = entryAddress[2];  //gets to the end of the linked list
				if (checkKey(keystring,entryAddress[0])) then 		//if matching key string
					entryAddress[1] = dataPTR;
					return;
				endif;
			loop;
			entryAddress[2] = createNewDataEntry(keystring,dataPTR);
	else
		editDict(key,createNewDataEntry(keystring,dataPTR),dict); //if not in tree, create a new node in the tree
	endif;
end;

@int retrieveFromDict(@int dict, @char keystring)
	//returns the data pointer in a dictionary entry
	int key = simpleHash(keystring);
	entryAddress = findKey(key,dict); //gets address of a data ptr
	if (entryAddress) then
		if (checkKey(entryAddress[0],keystring)) then 
			//if the same, then return dict pointer
			return entryAddress[1];
		else //need to add to linked list
			while(entryAddress[2])do
				entryAddress = entryAddress[2];  //gets to the end of the linked list
				if (checkKey(keystring,entryAddress[0])) then 		//if matching key string
					return entryAddress[1]; 							//return ptr
				endif;
			loop;
			return 0; //if gets to end without finding matching key string, then return 0
	else
		return 0; //if not in tree, return failure
	endif;
end;

int deleteFromDict(@int dict, @char keyString)
	//returns 1 for success, 0 for fail
	int key = simpleHash(keystring);
	entryAddress = findKey(key,dict); //gets address of a data ptr
	if (entryAddress) then
		if (checkKey(entryAddress[0],keystring)) then 
			//if the same, then delete node
			if (entryAddress[2]) then 
				//needs to change pointer in tree
				editDict(key,entryAddress[2],dict);
			else
				deleteTreeNode(key);
			endif;
			@char entryKeyString = entryAddress[0];
			dalloc(entryKeyString);
			dalloc(entryAddress);
			return 1; //success
		else //need to add to linked list


			//////////////////////////////////////////////////////////////////////
			// NEEDs TO DEAl WITH LINKED LIST PART - UNFINISHED 				//
			//////////////////////////////////////////////////////////////////////
			while(entryAddress[2])do
				entryAddress = entryAddress[2];  //gets to the end of the linked list
				if (checkKey(keystring,entryAddress[0])) then 		//if matching key string
					return entryAddress[1]; 							//return ptr
				endif;
			loop;
			return 0; //if gets to end without finding matching key string, then return 0
			//////////////////////////////////////////////////////////////////////////
			// END OF UNFINISHED SECTION 											//
			//////////////////////////////////////////////////////////////////////////	
	else
		return 0; //if not in tree, return failure
	endif;
end;

//__________________________________ AUXILARY DICT EDITTING FUNCTIOnS __________________________________

@int createNewDataEntry(@char keystring, int dataPTR)
	//allocate space for a copy of the keystring
	int keystringLength = getLength(keystring);
	if (keystringLength&3) then keystringLength = 1 + (keystringLength>>2); else keystringLength = keystringLength>>2; endif;  //pads if needed, uses &3 and <<2 for %4 and *4 respectively
	@char keyStringCopy = malloc(keystringLength); 					//allocates a section of memory of desired length
	copyString(keystring,keyStringCopy,keystringLength<<2);  		//copies key string
	//allocate space for the newDictEntry
	@int return_value = malloc(4);
	return_value[0] = keyStringCopy; //adds in pointers to keystring and data pointer
	return_value[1] = dataPTR;
	return_value[2] = 0; 				//nullifies end node
	return return_value; 
end;

int checkKey(@char key1, @char key2)
	//checks if two strigns are equal
	//returns 1 for equal, 0 for not
	int i = 0;
	while(key1[i])do
		if (key1[i] != key2[i]) then return 0; endif;
		i = i + 1;
	loop;
	if (key2[i])then return 0;
	return 1;
end;

void copyString(@char source, @char destination, int total_length)
	int i;
	state = 0;
	for (i = 0; i<total_length,i = i+1)
		if (state) then
			destination[i] = source[i];
			if (not(source[i])) then
				state = 0;
			endif;
		else
			destination[i] = 0;
	loop;
end;


int getLength(@char string)
	//finds length of a string
	int count = 0;
	for (count = 0, string[count], count = count + 1) continue; loop;
	return count;
end;