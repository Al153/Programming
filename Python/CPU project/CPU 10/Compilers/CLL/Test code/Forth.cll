//Trying to produce forth in CLL - may end up in assembly instead



//defnitions within forth

//word dctionary format:
//
//8 bytes of name, an int of code pointer, an int of next entry pointer
//  ADDR 	CONTENTS 			Remarks
//			-----------------
//	x  :x+3	| E | X | A | M |   8 byte character name, other bytes = 0
//			-----------------
//	x+4:x+7	| P | L | E | 0 |   ditto
//			-----------------
//	x+8:x+B	|    ABCD0123   |   code pointer, 4 bytes, points to the byte code of the particular instruction
//			-----------------
//	x+c:x+f	|    0123ABCD   | 	next entry pointer, points to the next dictionary entry
//			-----------------


// functions needed relating to dictionary entries:
	// compare name (name, reference) ==> true or false - compares a string against the name of and entry
	// search dictionary (name) ==> reference 		 	- searches the dictionary for the matching entry - makes use of compare_name  
	// execute dictionary entry (reference) ==> none 	- executes the bytecode from a dictionary reference
	// outer interpreter 								- executes bytecode 



//Bytecode format:
//bytecode for and instruction constists of a linked list of bytecode instructions

//bytecode instructions can be different lengths depending on the type of instructions.

//			word call 							  			push literal					branch  										primitive (CLL code)
//
// int0		type:word call      							type: PushLit					type: control flow 						 		type: primitive
// int1     dictionary entry of word to be called   		literal to push					Next Bytecode0		 							primitive identifier
// int2		next Bytecode  		                     		Next Bytecode			 		Next Bytecode1 									Next Bytecode
// int3 	flags 											flags 							flags 											flags
//

// notes:
	// the type field consists of some identifying number
	// the last link to Next Bytecode in a chain will be 0, indicating to return 
	// the flags int is used during compiliation to check whether a node has been touched

// Functions relating to Bytecodes:

	// Bytecode interpeter: proceeds through bytecode list executing instructions, can execute any bytecode instruction and when it hits a primitive, performs a Goto to the machine code
	//						and executes it, storing the current instruction before hand
	
	// A  set of primitives: primitives will allow forth to modify its own state. I plan on making "addToDictionary", "outerInterpreter" and parts of "Compile" primitives


#define WORDCALL 1
#define PUSHLIT 2
#define BRANCH 5
#define PRIMITIVE 6
/////////////////////////////////  Main bytecode interpeter //////////////////////////////////////

void bytecode_interp(@int reference)
	while((reference)and(dontBreak))do
		int opType = reference[0];
		if (opType == WORDCALL) then
			reference = reference[1];
			bytecode_interp(reference[2]); //reference points to the dictionary entry
			reference = reference[2];
		else if(opType == PUSHLIT) then
			PushLit(reference[1]);
			reference = reference[2];
		else if (opType == BRANCH) then
			int branch = Pop();
			if (branch) then reference = reference[1]; else reference = reference[2]; endif;
		else if (opType == PRIMITIVE) then
			executePrimitive(reference[1]);
			 reference = reference[2];
		else
			printf("ERROR: unrecognised bytecode: "); print_i(opType);
			quit();

		endif;
		endif;
		endif;
		endif;
		endif;
		endif;
	loop;
end;

/////////////////////////////// Stack tools for bytecode interpeter /////////////////////////////////
#define FORTHSTACKSIZE 65536
@int FORTHSTACKSIZE ForthStack;
int ForthStackPointer = 0;



void PushLit(int number)
	ForthStack[ForthStackPointer] = number;
	ForthStackPointer = ForthStackPointer + 1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack Overflow.\n");
		dontBreak = 0; //breaks to the REPL 
	endif;
end;

char dontBreak = 1;

#include allocation.cll
void init_primitives()
	//sets up dictionary etc
	malloc_init();
end;

void executePrimitive(int primitive_reference)
	//picks primitive to run and runs it

	////////////////  PRIMITIVE OPCODES ////////////////////////////
	// @     00   	| +  08 	| ~  		10 | == 		18 |
	// !     01 	| -  09 	| ~&        11 | VARIABLE 	19 |
	// .     02 	| *  0A 	| ~|  		12 | CONST   	1A |
	// DUP   03 	| /  0B 	| ~^ 	  	13 | TABLE      1B |
	// SWAP  04 	| %  0C 	| << 		14 | COMPILE 	1C |
	// ROT   05 	| &  0D 	| >> 	    15 | READ 		1D |
	// OVER  06 	| |  0E 	| < 		16 | EVAL 		1E |
	// DROP  07 	| ^  0F 	| >         17 |
	////////////////////////////////////////////////////////////////

	//READ, EVAL, COMPILE, CONST, VARIABLE, TABLE are technical interpreted words, and probably wont be linked to user generated words
end;

////////////////////////  STACK primitives //////////////////////////

void PushVar(@int address)
	ForthStack[ForthStackPointer] = address[0];
	ForthStackPointer = ForthStackPointer + 1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack Overflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
end;

void PopVar(@int address)
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	address[0] = ForthStackPointer[ForthStackPointer];
end;

int Pop()
	//pops off of stack
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	return ForthStackPointer[ForthStackPointer];	
end;

void Push(int value)
	//pushes onto stack
		
		ForthStackPointer = ForthStackPointer + 1;
		if (ForthStackPointer>FORTHSTACKSIZE) then
			printf("ERROR: Forth Stack Overflow.\n");
			dontBreak = 0; //breaks to the REPL
			return; 
		endif;
		ForthStack[ForthStackPointer] = value;
end;

void Dup()
	if (ForthStackPointer>0) then //if stack has a value on it then
		ForthStack[ForthStackPointer+1] = ForthStack[ForthStackPointer];
		ForthStackPointer = ForthStackPointer + 1;
		if (ForthStackPointer>FORTHSTACKSIZE) then
			printf("ERROR: Forth Stack Overflow.\n");
			dontBreak = 0; //breaks to the REPL 
		endif;
	else
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL	
	endif;
end;

void Drop()
	if (ForthStackPointer>0) then //if stack has a value on it then
		ForthStackPointer = ForthStackPointer -1 ;
	else
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL	
	endif;
end;


void Swap()
	if (ForthStackPointer>1) then //if stack has a value on it then
		int temp = ForthStack[ForthStackPointer-1];
		ForthStack[ForthStackPointer-1] = ForthStack[ForthStackPointer];
		ForthStack[ForthStackPointer] = temp;
	else
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL	
	endif;
end;

void Rot()
	if (ForthStackPointer>2) then //if stack has a value on it then
		int temp = ForthStack[ForthStackPointer];
		ForthStack[ForthStackPointer] = ForthStack[ForthStackPointer-1];
		ForthStack[ForthStackPointer-1] = ForthStack[ForthStackPointer-2];
		ForthStack[ForthStackPointer-2] = temp;
	else
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL	
	endif;
end;

void Over()
	if (ForthStackPointer>1) then //if stack has a value on it then
		ForthStack[ForthStackPointer+1] = ForthStack[ForthStackPointer-1];
		ForthStackPointer = ForthStackPointer + 1;
		if (ForthStackPointer>FORTHSTACKSIZE) then
			printf("ERROR: Forth Stack Overflow.\n");
			dontBreak = 0; //breaks to the REPL 
		endif;
	else
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL	
	endif;
end;


////////////////////////// primitives /////////////////////////////////////
char dontBreak = 1;

#include allocation.cll
void init_primitives()
	//sets up dictionary etc
	malloc_init();

	//sets up operators
	editDictEntry("@",newByteCodeNode(PRIMITIVE,0,0));
	editDictEntry("!",newByteCodeNode(PRIMITIVE,1,0));
	editDictEntry(".",newByteCodeNode(PRIMITIVE,2,0));
	editDictEntry("DUP",newByteCodeNode(PRIMITIVE,3,0));
	editDictEntry("SWAP",newByteCodeNode(PRIMITIVE,4,0));
	editDictEntry("ROT",newByteCodeNode(PRIMITIVE,5,0));
	editDictEntry("OVER",newByteCodeNode(PRIMITIVE,6,0));
	editDictEntry("DROP",newByteCodeNode(PRIMITIVE,7,0));
	editDictEntry("+",newByteCodeNode(PRIMITIVE,8,0));
	editDictEntry("-",newByteCodeNode(PRIMITIVE,9,0));
	editDictEntry("*",newByteCodeNode(PRIMITIVE,10,0));
	editDictEntry("/",newByteCodeNode(PRIMITIVE,11,0));
	editDictEntry("%",newByteCodeNode(PRIMITIVE,12,0));
	editDictEntry("&",newByteCodeNode(PRIMITIVE,13,0));
	editDictEntry("|",newByteCodeNode(PRIMITIVE,14,0));
	editDictEntry("^",newByteCodeNode(PRIMITIVE,15,0));
	editDictEntry("~",newByteCodeNode(PRIMITIVE,16,0));
	editDictEntry("~&",newByteCodeNode(PRIMITIVE,17,0));
	editDictEntry("~|",newByteCodeNode(PRIMITIVE,18,0));
	editDictEntry("~^",newByteCodeNode(PRIMITIVE,19,0));
	editDictEntry("<<",newByteCodeNode(PRIMITIVE,20,0));
	editDictEntry(">>",newByteCodeNode(PRIMITIVE,21,0));
	editDictEntry("<",newByteCodeNode(PRIMITIVE,22,0));
	editDictEntry(">",newByteCodeNode(PRIMITIVE,23,0));
	editDictEntry("==",newByteCodeNode(PRIMITIVE,24,0));
	editDictEntry("VARIABLE",newByteCodeNode(PRIMITIVE,25,0));
	editDictEntry("CONST",newByteCodeNode(PRIMITIVE,26,0));
	editDictEntry("TABLE",newByteCodeNode(PRIMITIVE,27,0));
end;

void executePrimitive(int primitive_reference)
	//picks primitive to run and runs it
end;

//////////////////////// Arithmetic /////////////////////////////////

//arithmetic primitives for forth, arithmetic is 2s complement
void ADD()
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	ForthStack[ForthStackPointer] = ForthStack[ForthStackPointer]+ForthStack[ForthStackPointer+1];
end;
void SUB()
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	ForthStack[ForthStackPointer] = ForthStack[ForthStackPointer][ForthStack[ForthStackPointer+1];
end;
void MUL()
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	ForthStack[ForthStackPointer] = ForthStack[ForthStackPointer]*ForthStack[ForthStackPointer+1];
end;
void DIV()
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	ForthStack[ForthStackPointer] = ForthStack[ForthStackPointer]/ForthStack[ForthStackPointer+1];
end;
void MOD()
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	ForthStack[ForthStackPointer] = ForthStack[ForthStackPointer]%ForthStack[ForthStackPointer+1];
end;
void AND()
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	ForthStack[ForthStackPointer] = ForthStack[ForthStackPointer]&ForthStack[ForthStackPointer+1];
end;
void OR()
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	ForthStack[ForthStackPointer] = ForthStack[ForthStackPointer]|ForthStack[ForthStackPointer+1];
end;
void XOR()
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	ForthStack[ForthStackPointer] = ForthStack[ForthStackPointer]^ForthStack[ForthStackPointer+1];
end;
void NOT()
	ForthStack[ForthStackPointer] = ~ForthStack[ForthStackPointer];
end;

void NAND()
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	ForthStack[ForthStackPointer] = ~(ForthStack[ForthStackPointer]&ForthStack[ForthStackPointer+1]);
end;
void NOR()
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	ForthStack[ForthStackPointer] = ~(ForthStack[ForthStackPointer]|ForthStack[ForthStackPointer+1]);
end;
void XNOR()
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	ForthStack[ForthStackPointer] = ~(ForthStack[ForthStackPointer]^ForthStack[ForthStackPointer+1]);
end;

//////// Variables and constants //////////
void createConstant()
	@char 9 name; //9 to pad a zero on the end
	convertName(scanWord();,name);   //produces an acceptable name
	int n = Pop(); 					 //n on stack
	editDictEntry(name,newByteCodeNode(PUSHLIT,n,0)); //creates a word
end;

void createVariable()
	@char 9 name; //9 to pad a zero on the end
	convertName(scanWord();,name);   //produces an acceptable name
	int address = malloc(1); 					 //allocates memory
	editDictEntry(name,newByteCodeNode(PUSHLIT,address,0)); //creates a word
end;

void createTable()
	@char 9 name; //9 to pad a zero on the end
	convertName(scanWord();,name);   //produces an acceptable name
	int address = malloc(Pop()); 					 //n on stack
	editDictEntry(name,newByteCodeNode(PUSHLIT,address,0)); //creates a word
end;

void convertName(@char name_string,@char buffer)
	//copies name into buffer, pads with zeroes
	int pad =0;
	int i;
	for(i = 0, i<8,i = i + 1)
		if (pad) then buffer[i] = 0;
		else
			if (isWhiteSpace(name_string[i])) then pad = 1; buffer[i] = 0;
			else
				buffer[i] = name_string[i];
			endif;
		endif;
	loop;
	name_string[8] = 0;
end;

void printTOS()
	int TOS = Pop();
	if (TOS&2147483648) then printf("-"); print_i(TOS&2147483647); return; endif;
	print_i(TOS);
end;

//////// comparison //////////
void greater()
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	int a = ForthStack[ForthStackPointer];
	int b = ForthStack[ForthStackPointer+1];
	if ((a&2147483648) and (b&2147483648)) then  ForthStack[ForthStackPointer] = __less(a,b); //if both are negative then return (a<b)
	else if (a&2147483648) then ForthStack[ForthStackPointer] = 0; 							  //else if a is negative then return 0;
		else if (b&2147483648) then ForthStack[ForthStackPointer] = 1; 						  //else if b is negative then return 1;
			else ForthStack[ForthStackPointer] = __greater(a,b);
			endif;
		endif;
	endif;
end;

void less()
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	int a = ForthStack[ForthStackPointer];
	int b = ForthStack[ForthStackPointer+1];
	if ((a&2147483648) and (b&2147483648)) then  ForthStack[ForthStackPointer] = __greater(a,b); //if both are negative then return (a>b)
	else if (a&2147483648) then ForthStack[ForthStackPointer] = 1; 							  //else if a is negative then return 1;
		else if (b&2147483648) then ForthStack[ForthStackPointer] = 0; 						  //else if b is negative then return 0;
			else ForthStack[ForthStackPointer] = __less(a,b);
			endif;
		endif;
	endif;
end;
void equal()
	ForthStackPointer = ForthStackPointer-1;
	if (ForthStackPointer>FORTHSTACKSIZE) then
		printf("ERROR: Forth Stack underflow.\n");
		dontBreak = 0; //breaks to REPL
	endif;
	ForthStack[ForthStackPointer] = __equal(ForthStack[ForthStackPointer],ForthStack[ForthStackPointer+1]); //if both are negative then return (a>b)
end;
void __greater(int a, int b) if (a>b) then return 1; else return 0; endif; end;
void __less(int a, int b) if (a<b) then return 1; else return 0; endif; end;
void __equal(int a, int b) if (a==b) then return 1; else return 0; endif; end;


//////////////////////// Dictionary management //////////////////////

@int ForthDictHead = 0;
@int ForthDictTail = 0;

void editDictEntry(@char name, @int codePtr)
	//tries to edit the code pointer of a word in the dictionary, if word doesnt already exist, then add a new one at the top of the dictionary
	int dict = ForthDictHead;
	int address = isInDict(name,dict);
	if (address) then 
		if ((address[2])and(address[2] != codePtr])) then
			collectGarbage(address[2]);
			address[2] = codePtr;

		endif;
	else
		//add to dictionary
		@int newEntry = newDictInst(name,codePtr);
		newEntry[2] = ForthDictHead;
		ForthDictHead = newEntry;
	endif;
end;

int checkDictName(@char name, @char reference)
//returns 1 for match, 0 for fail
	int i;
	for (i = 0, i<8, i = i + 1)
		if (name[i] != reference[i]) then return 0; endif; //fail
		if (name[i] == 0) then return 1; endif; //end of string, success
	loop;
end;

@int isInDict(@char name,@int dict)
	while(dict)do
		if(checkDictName(name,dict))then return dict; endif;
		dict = dict[3];
	loop;
	return 0; //failure 
end;


@int newDictInst(@char name, @int codePtr)
	@int returnPTR = malloc(4);
	// set up name
	@char name_pointer;
	int i = 0;
	while (i<8) do
		if (name[i]) then
			name_pointer[i] = name[i];
		else
			break;
		endif;
		i = i + 1;
	loop;
	while (i<8) do name_pointer[i] = 0; i = i + 1; loop; //initialise rest with zeros
	returnPTR[2] = codePtr;
	returnPTR[3] = 0;
	return returnPTR;
end;

///////////////////////// Bytecode generation /////////////////////////
@int newByteCodeNode(int type, int field1, int field2)
	@int returnPTR = malloc(4); //requires 4 ints to represent a bytecode op
	returnPTR[0] = type;
	returnPTR[1] = field1;
	returnPTR[2] = field2;
	returnPTR[3] = 0; 					//sets flags to zero
end;


void collectGarbage(@int node)
	//deallocates node and all its descendents, recursively
	if (not(node[3])) then 		//if not marked
		node[3] = 1; 			//marks
		if (node[0] == BRANCH) then
			collectGarbage(node[2]); //deallocates other node
		endif;
		collectGarbage(node[1]); //deallocates default pointed to node
		dalloc(node); 			 //calls actual dalloc routine for deallocation
	endif;
end;

///////////////////////// IO //////////////////////////////
@char lineBuff;
int linePtr;
int READ_IN_STATE = EMPTY;
#define EMPTY 0
#define FULL 1

void readIn(@char buf)
	linePtr = 0;
	int i = 0;
	char character;
	while (1) do
		character = getw();
		if (character == 13) then
			buf[i] = 0; //nullifies string
			break;
		else
			buf[i] = character;
			i = i+1;
		endif;
	loop;
	READ_IN_STATE = FULL;
end;


@char scanWord()
	//returns pointer to the next word on the input buffer, and leaves linePtr at the end of the word. if the buffer is empty then reset and read in
	if(READ_IN_STATE == EMPTY)then readIn(lineBuff); endif; //reads in another line
	while (isWhiteSpace(lineBuff[linePtr])) do linePtr = linePtr + 1; loop;
	@char return_value = lineBuff+linePtr; //value to return points to the start of the word
	while (not(isWhiteSpace(lineBuff[linePtr]))) do linePtr = linePtr + 1; loop;
	if (lineBuff[linePtr] == '\n') then READ_IN_STATE = EMPTY; endif;
	return return_value;
end;

int isWhiteSpace(char input)
	//checks if a character is whitespace or not
	if (input == ' ') then
		return 1;
	else
		if (input == '\n') then
			return 1;
		else
			if (input == '\t') then
				return 1;
	endif; endif; endif;
	return 0;
end;

//////////////////  Compiler/interpreter ///////////////////////////

// functions to run the interpreter and compiler


void compileWord()
	//compiles a word defintion
end;

@int compileSingleWord()
	primRead(); // reads in a word to the buffer
	if (checkDictName(WORD_BUF,";")) then //scans word against special words .. if, while etc

	else
		if (checkDictName(WORD_BUF,"IF")) then
	
		else
			if (checkDictName(WORD_BUF,"WHILE")) then
	
			else
				if (checkDictName(WORD_BUF,"FOR")) then
	
				else
					if (checkDictName(WORD_BUF,"VALUE")) then  //value table and constant chould be interpreted
	
					else 
						if (checkDictName(WORD_BUF,"TABLE")) then
	
						else
							if (checkDictName(WORD_BUF,"CONSTANT")) then
	
							else //if a normal word, then lookup reference
								@int reference = isInDict(WORD_BUF,ForthDictHead);
								if (reference) then  return newByteCodeNode(WORDCALL,reference,0); 
								else printf("ERROR: unrecognised word compiled\n");				//maybe return an error in the future - go back to REPL
								endif;
							endif;
						endif;
					endif;
				endif;
			endif;
		endif;
	endif;
end;




@char 9 WORD_BUF; //global var containing the name of a word


//////////// words to construct the interpreter
void primRead()
	convertName(scanWord(),WORD_BUF); //puts the word name into the global buffer
end;

void primIsInDict()
	//primitive version of is in dict
	Push(isInDict(WORD_BUF,ForthDictHead));
end;

void primExecute()
	bytecode_interp(Pop());
end;

void isInt()
	int i = 0;
	while (WORD_BUF[i])do
		if (not((WORD_BUF[i]>='0')and (WORD_BUF[i]<='9'))) then return 0; endif; //if not a digit then failed
	loop;
	retun 1; //if hasnt returned then is an int
end;

void convertInt()
	//converts WORD_BUF to an int and pushes it
	int dec = 0;
	int i;
	for(i=0, WORD_BUF[i] ,i = i+1)
		dec = dec * 10 + ( WORD_BUF[i] - '0' );
	loop;
	Push(dec);
end;

//self interpreting code: - I need to manually compile these
//: INTERP 1 while READ EVAL PRINTRESULT 1 LOOP ;
//: EVAl DUP isInDict DUP if EXECUTE else DROP TRYINT then ;
// : TRYINT isInt if convertInt else INPUTERROR then ;

//: READ [primREAD] ;
//: EXECUTE [primEXECUTE] ;
//: isInt [primInInt] ;
//: convertInt [primConvertInt]