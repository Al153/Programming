// code to take assembly language, assemble it into AIF (assembler intermediate form) and then render that form into memory and execute it


///////////////////////////////////////////////////////////////////////////////
//Loader section
// Assembly reduced to intermediate tree form, which is now loaded into memory and offsets added



// structure of the tree is a linked list of line objects
//line objects have 4 fields:
//	- Address 			- address of line - the offset is added to this and the contents of the line is stored into memory at that points
//	- Line link 		- pointer to rest of the line (a one or two int section containing the data of the line)
//	- next link 		- pointer to the next line, if zero then termiate loading and execute
//	- apply offset 		- if true then the offset is also added to the specific field of the intruction (or data)
//  - type				- type of line:
// 							- 0: error
//							- 1: instruction
//							- 2: data - int
//							- 3: data - byte  -ignoring words in this

#include allocation.cll
#include hashTable.cll
//does the allocation

void Load(@int AIF_tree, @char offset)
	//progress through tree, rendering it to memory starting at offset
	//the entire tree should be malloc-ed so that it can be dalloc-ed
	while (AIF_tree != 0) do //loops through all of tree
		render(AIF_tree,offset); //render function will render the line
		@int new_AIF_tree = AIF_tree[2];	//gets the next line
		dalloc(AIF_tree); AIF_tree = new_AIF_tree;
	loop;
	//tree now rendered into memory, now uses HAX to execute the machine code
	HAX(offset); //Hardware Assembly eXecution  :)
end;

void render(@int AIF_tree, @char offset)
	@int address = AIF_tree[0];
	@int line_pointer = AIF_tree[1];
	int type = AIF_tree[4];
	int do_offset = AIF_tree[3];
	if ((type == 0)or(type>3)) then
		 //invalid; raise error
		printf("ERROR: tried to process unknown tree node");
		quit();
	endif;
	if (type == 1) then
		//regular instruction; 8 bytes worth of information. Do offset refers to second int
		address += offset; 					//address now points to the correct location
		address[0] = line_pointer[0];
		address[1] = line_pointer[1]+(offset if do_offset else 0);		//if offset flag is true then add an offset to the address part
	else if (type == 2) then
		address += offset;
		address[0] = line_pointer[0]+ (offset if do_offset else 0); 	//if offset flag is true then add an offset to the data
	else
		//byte data
		//do_offset has no effect
		@char byte_address = address + offset;
		byte_address[0] = char(line_pointer[0];)
	endif; endif;
	dalloc(line_pointer); //deallocates the line
end;

void HAX(int address_to_execute)
	@int anchor = @address_to_execute; //gets anchor to the address to execute
	anchor[-12] = address_to_execute;
	anchor[-8] = address_to_execute; // don't know which position the address to execute variable will be in so spams both possible offsets to put new address into the return address
end; //this return reads the edited  return address and jumps to an arbitary address (address to execute)



////////////////////////////////////////////////////////// ASSEMBLER PART ////////////////////////////////////////////////////////////////
@int definedDict; 			//global vars
@int variableDict;

void init()
	malloc_init();
	definedDict = newDict("ROOT","ROOT");
	variableBDict = newDict("ROOT","ROOT")
end;

#define EXECUTE 1
#define DUMP 2

void assemble(@char source_text, int mode)
	init();
	@int tokens = parse(source_text);
	second_pass(tokens);
	@int AIF = generate_intermediate(tokens);

	if (mode == EXECUTE) then 
		Load(AIF,END_OF_PROGRAM); //need to look into output to find a way to calculate end of program - failing that we can just produce a large array to write to
	endif;
end;



@int Parse(@char source_text)
	@int top = tokenise(source_text);
	@int line;
	@int previous_line = @top;



	//generates a tree form for code
	//line object <--> token <--> token <--> token -->|
	//    ||
	//   ||
	//   \/
	//line object <--> token <--> token <--> token -->|
	//	||
	//	||
	//	\/
	//	__ 
	//checks for definitions and intLiterals
	// if a definition, then it should delete line and add definition to the defined dictionary
	// int literal, just add a variable definition at the top of the code
	// expands goto macro
	for (line = top, line != 0, line = line[0])
		//check for comments
		remove_comments(line,previous_line);
		scan_definitions(line);
		check_int_literals(line);



		previous_line = line;
	loop;
	return top;
end;

void second_pass(@int tokens)
	//tries to replace all tokens from dictionary
	// reorders if .. then ..s to ... if ...
	// checks for labels - creates label variables too - add direct to dict
	// checks for variables - add to dict
	// adds line types
	// adds line sizes
end;

@int generate_intermediate(@int tokens)
	// takes a token list
	// renders into machine code fragments (line by line)
	// replaces variables and adds line numbers (generates addresses)
	// places offsets
	// deallocates token tree
end;



int get_character_type(char character)
	#define SPACING 1
	#define ELEMENT 2
	#define LINE_MARK 3
	#define EOF 4
	#define ID 5

	if (character == 0) then return EOF; endif;
	if (((character == '\n') or (character == ';'))or (character == ',')) then return LINE_MARK; endif;
	if ((character== ' ') or (character == '\t')) then return SPACING; endif;
	if  ((character == '#') or
		(((character == '$')or (character == '%')) or
		((character == '@') or (character == '\'') or
		((character == '[') or(character == ']'))
		))) then return ELEMENT; endif;
	return ID;
end;

@int tokenise(@char source_text)
	#define START 1
	#define NEW_TOKEN 2
	#define IN_TOKEN 3
	#define END 4
	@int top;
	//parser basics:
		// tokens are letters or numbers, separated by spaces or tabs. Lines are separated by \n or ;
		// @ [ ] % $ all cause new tokens to be formed
		//token object is
		// ________________
		// | Forward link |
		// |--------------|
		// | backward link|
		// |--------------|
		// | tokentext ptr|
		// |--------------|
		// | type | length| --length is bottom byte, type is top byte, lines up to 256 chars
		// |--------------|

		// malloc size = 4

		// Line object is
		// _________________
		// | Forward link  |
		// -----------------
		// | Line link 	   |
		// -----------------
		// | Line type 	   |
		// -----------------
		// | line size 	   |
		// -----------------
		// malloc size = 4
	//malloc has space for about 1000 lines
	@int current_line = malloc(4);
	top = current_line;
	@int current_token;
	@int new_token 
	@int parent = @top;
	int i;

	int parse_state = START;  //start is at the beginning of a line

	for (i = 0, 1 , i += 1)
		char character = source_text[i];
		character_type = get_character_type(character)
		// state = START
			// character = "\t", ", "\n", ";" ==> START ()
			// character = "@", "[", "]", "%", "$","'","#" ==> NEW_TOKEN (create new token object; put character into it; length = 1; link current line and this token; create second token - empty; link two tokens)
			// character = 0x00 ==> END (delete current line node; parent's forward link = 0)
			// character = else ==> IN_TOKEN (create new token object; put token text_ptr; leave length empty; link to current line)
		if (state == START) then
			if ((character_type == SPACING) or (character_type == LINE_MARK)) then
				continue;
			else if (character_type == ELEMENT) then
				current_token = malloc(4);
				current_token[[1]] = 0;
				current_token[2] = source_text + i;
				current_token[3] = 1;
				current_line[1] = current_token;
				new_token = malloc[4];
				current_token[0] = new_token;
				new_token[1] = current_token;
				current_token = new_token


				state = NEW_TOKEN;
			else if (character_type == EOF) then
				dalloc(current_line);
				parent[0] = 0;
				state = END;
			else
				current_token = malloc(4);
				current_token[[1]] = 0;
				current_token[2] = source_text + i;
				current_line[1] = current_token;
				state = IN_TOKEN;
			endif; endif; endif;


		// state = NEW_TOKEN
			// character = " ", "\t" ==> NEW_TOKEN ()
			// character = "@", "[", "]", "%", "$","'","#" ==> NEW_TOKEN (store character into current token; kength = 1; create new empty token; link tokens )
			// character = ";","\n" ==> START (delete current token, set previous token's ppointer to 0; new line object; update parent; do line linkage)
			// character = 0x00 ==> END (current line.forward link = 0; delete current token, previous token.forward_link = 0)
			// character = else ==> IN_TOKEN (character's address goes into current token.text_ptr)
		else if (state == NEW_TOKEN) then
			if (character_type == SPACING) then
				continue;
			else if (character_type == ELEMENT) then
				current_token[2] = source_text + i;
				current_token[3] = 1;
				new_token = malloc(4);
				current_token[0] = new_token;
				new_token[1] = current_token;
				current_token = new_token;
				state = new_token;

			else if (character_type == LINE_MARK) then
				new_token = current_token[1];  //new token is a stand in for previous token
				new_token[0] = 0;
				dalloc(current_token);
				parent = current_line;
				current_line = malloc(4);
				parent[0] = current_line;

				state = START
			else if (character_type == EOF) then
				current_line[0] = 0;
				new_token = current_token[1]; //new token is a stand in for previous token
				dalloc(current_token);
				new_token[0] = 0;
				state = END;
			else
				current_token[2] = source_text + i;
				state = IN_TOKEN;
			endif; endif; endif; endif;

		// state == IN_TOKEN
			// character = " ", "\t" ==> NEW_TOKEN(current_token.length = address_of_character - current_token.text_ptr; create new token object; do linkage)
			// character = "@", "[", "]", "%", "$","'","#" ==> NEW_TOKEN ( current_token.length = address_of_character - current_token.text_ptr; create new token object; do linkage; create new current token; store character into current token; kength = 1; create new empty token; link tokens )
			// character = ";", "\n" ==> START (current_token.length = address_of_character - current_token.text_ptr; current_token.next = 0; create new line object; do line linkage; )
			// character = 0x00 ==> END (current_token.length = address_of_character - current_token.text_ptr; current_token.next = 0; current_line.next = 0)
			// character = else ==> IN_TOKEN ()
		else if (state == IN_TOKEN) then
			if (character_type == SPACING) then
				current_token[3] = source_text + i - current_token[2];
				new_token = malloc(4);
				current_token[0] = new_token;
				new_token[1] = current_token;
				current_token = new_token;

				state = NEW_TOKEN;
			else if (character_type == ELEMENT) then
				current_token[3] = source_text + i - current_token[2];
				new_token = malloc(4);
				current_token[0] = new_token;
				new_token[1] = current_token;
				current_token = new_token;

				current_token[2] = source_text + i;
				current_token[3] = 1;

				new_token = malloc(4);
				current_token[0] = new_token;
				new_token[1] = current_token;
				current_token = new_token;

				state = NEW_TOKEN;
			else if (character_type == LINE_MARK) then
				current_token[3] = source_text + i - current_token[2];
				current_token[0] = 0;
				parent = current_line;
				current_line = malloc(4);
				parent[0] = current_line;


				state = START;
			else if (character_type == EOF) then
				current_token[3] = source_text + i - current_token[2];
				current_token[0] = 0;
				current_line[0] = 0;

				state = END;
			else
				continue;
			endif; endif; endif; endif;
		// state = END
			// break ()
		else
			break;
		endif; endif; endif;
	loop;
	return top;
end;

void remove_comments(@int line, @int previous_line)
	//scans line's tokens looking for hashtags which aren't in '', if found then removes as comment
	@int token;
	int state =0;
	for (token = line[1], token, token = token[0])
		if (token[3] == 1) then 		//only looks at tokens of length 1
			char character = token[2];
			if (character[0] == '\'') then state ^= 1;
			else if (character[0] == '#') then
					if (state == 0) then 			//if not a literal and a # is found then remove the # and anything after it
						if (token[1]) then 			//if not the first token in line
							token = token[1];
							@int new_token = token[0];
							token[0] = 0;
							while (new_token) do
								dalloc(new_token);
								new_token = new_token[0];
							loop;
						else
							previous_line[0] = line[0];
							dalloc(line);
							while (token) do 
								dalloc(token);
								token = token[0];
							loop;
						endif;
					endif;
				endif
			endif;
		endif;
	loop;
end;

void scan_definitions(@int line)
	
end;