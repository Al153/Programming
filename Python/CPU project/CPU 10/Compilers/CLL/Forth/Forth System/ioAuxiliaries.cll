//Functions and procedures used by the interpreter for IO

///////////////////////// IO //////////////////////////////
@char 256 keyboardBuff;
@int 4097 diskBuff;
int diskPtr = 0;
@char lineBuff = keyboardBuff;
int linePtr = 0;
int keyboardPtr;
int READ_IN_STATE = EMPTY;
int READ_IN_MODE = KEYBOARD;
@char 9 WORD_BUF; //global var containing the name of a word
int EOL = 0; //used as extra state to trigger OKs
#define EMPTY 0
#define FULL 1
#define KEYBOARD 0
#define DISK 1


void readInOld(@char buf) //old readIn function - doesn't handle backspaces.
	linePtr = 0;
	int i = 0;
	char character;
	while (1) do
		character = getw();
		putc(character); //so it can be seen
		if (character == 13) then
			buf[i] = 0; //nullifies string
			break;
		else
			buf[i] = character;
			i = i+1;
		endif;
	loop;
	READ_IN_STATE = FULL;
end;

void readIn(@char buf) //new readIn function - handles backspaces
	if (READ_IN_MODE == DISK) then
		changeMode(KEYBOARD); //hand back keyboard control
		return;
	else linePtr = 0; endif;
	char character;
	char lineFeed = 10;
	char blank = 0;
	char backSpace = 8;	
	while (1) do
		character = getw();
		putc(character);
		if (character == 13) then
			buf[linePtr] = 0; //nullifies string
			putc(lineFeed);
			break;
		else
			if (character == 8) then
				if (linePtr>0) then
					buf[linePtr] = 0;
					linePtr = linePtr - 1;
					putc(blank);
					putc(backSpace);
				else putc('>');
				endif;
				continue;
			endif;
			buf[linePtr] = character;
			linePtr = (linePtr + 1)&255;
		endif;
	loop;
	linePtr += 1;
	while (linePtr) do 
		buf[linePtr] = 0; //clear rest of buffer
		linePtr = (linePtr + 1)&255;
	loop;
	linePtr = 0;
	READ_IN_STATE = FULL;
end;

@char scanWord()
	//returns pointer to the next word on the input buffer, and leaves linePtr at the end of the word. if the buffer is empty then reset and read in
	if(READ_IN_STATE == EMPTY)then readIn(lineBuff); endif; //reads in another line
	while (isWhiteSpace(lineBuff[linePtr])) do 
		linePtr = (linePtr + 1)&(255 if READ_IN_MODE == KEYBOARD else 4095); 
		if ((lineBuff[linePtr] == 13) or (lineBuff[linePtr] == 0)) then readIn(lineBuff);
		endif;
	loop;
	@char return_value = lineBuff+linePtr; //value to return points to the start of the word
	while (not(isWhiteSpace(lineBuff[linePtr]))) do linePtr = (linePtr + 1)&(255 if READ_IN_MODE == KEYBOARD else 4095);  loop; //scrolls on to the next whitespace
	if (isEOL()) then READ_IN_STATE = EMPTY; EOL = 1; endif;
	return return_value;
end;

int isEOL()
	//determines if there is an EOL before the start of the next word
	while (1) do
		if ((lineBuff[linePtr] == ' ')or(lineBuff[linePtr] == '\t')) then
			linePtr = (linePtr + 1)&(255 if READ_IN_MODE == KEYBOARD else 4095); 
		else if ((lineBuff[linePtr] == '\n')or(lineBuff[linePtr] == char(0))) then return 1; //eol
			else return 0;
			endif; 
		endif;
	loop;
end;

void changeMode(int newMode)
	if (newMode == KEYBOARD) then
		if (READ_IN_MODE == DISK) then diskPtr = linePtr; endif;
		READ_IN_MODE = KEYBOARD;
		lineBuff = keyboardBuff;
		linePtr = keyboardPtr;
	else
		if (READ_IN_MODE == KEYBOARD) then keyboardPtr = linePtr; endif; // handles a context switch from keyboard to disk
		READ_IN_MODE = DISK;
		lineBuff = diskBuff;
		linePtr = diskPtr;
	endif;
end;

int isWhiteSpace(char input)
	//checks if a character is whitespace or not
	if (input == char(0)) then return 1; endif;
	if (input == ' ') then
		return 1;
	else
		if (input == '\n') then
			return 1;
		else
			if (input == '\t') then
				return 1;
	endif; endif; endif;
	return 0;
end;

void convertName(@char name_string,@char buffer)
	//copies name into buffer, pads with zeroes
	int pad =0;
	int i;
	for(i = 0, i<8,i = i + 1)
		if (pad) then buffer[i] = 0;
		else
			if (isWhiteSpace(name_string[i])) then pad = 1; buffer[i] = 0;
			else
				buffer[i] = name_string[i];
			endif;
		endif;
	loop;
	buffer[8] = 0;
end;

char readStringChar()
	//reads in a single string character, refilling the input buffer if necessary
	if(READ_IN_STATE == EMPTY)then readIn(lineBuff); endif; //reads in another line
	if (lineBuff[linePtr] == 0) then READ_IN_STATE = EMPTY; endif;
	linePtr = (linePtr + 1)&(255 if READ_IN_MODE == KEYBOARD else 4095); 
	return lineBuff[linePtr-1];
end;

void scanToEndOfDef()
	//scans to the nearest semicolon or new line on the input
	char character;
	printf("Scanning to end of def\n");
	while (1) do
		character = readStringChar();
		if (character == ';') then break; endif;
		if (character == '\n') then break; READ_IN_STATE = EMPTY; endif;
		if (character == char(0)) then break; READ_IN_STATE = EMPTY; endif;
	loop;
	EOL = 1;
end;

int isInt()	
	//determines if the contents of WORD_BUF is an int
	int i = 0;
	int digCount = 0; //counts number of digits
	while (WORD_BUF[i])do
		if (not((WORD_BUF[i]>='0')and (WORD_BUF[i]<='9'))) then
			if (not((i == 0) and (WORD_BUF[i] == '-'))) then return 0; endif; //if not a preliminary minus sign
		endif;//if not a digit then failed
		if (not(WORD_BUF[i] == '-')) then digCount += 1; endif; //if there is a digit, then increment digCount
		i += 1;
	loop;
	if (digCount) then
		return 1; //if hasnt returned then is an int
	else
		return 0; //if no digits were seen (a single - sign, then there is no int)
	endif;
end;

int convertInt()
	//converts WORD_BUF to an int and returns it
	int negative = 0;
	int dec = 0;
	int i;
	for(i=0, WORD_BUF[i] ,i = i+1)
		if ((i == 0) and (WORD_BUF[i] == '-')) then negative = 1; continue; endif;
		dec = dec * 10 + ( WORD_BUF[i] - '0' );
	loop;
	return (0-dec) if negative else dec;
end;