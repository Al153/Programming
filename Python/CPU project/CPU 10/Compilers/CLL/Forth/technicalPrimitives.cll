//////////////////////// INNER INTERPRETER TECHNICAL PRIMITIVES ///////////////

//primitives not designed to be used by the user, but used to build the outer interpreter
void primRead()
	if (SOL) then SOL = 0; printf("\nOK\n"); printf("\n>>"); endif;
	convertName(scanWord(),WORD_BUF); //puts the word name into the global buffer
end;

void primIsInDict()
	//primitive version of is in dict
	Push(isInDict(WORD_BUF,ForthDictHead));
end;

void primExecute()
	@int ref = Pop();
	bytecodeInterp(ref[2]);
	dontBreak = 1; //if a subroutine causes a break then the break doesn't unwravel past the outer interpreter
	if (EOL) then EOL = 0; SOL = 1;endif;
end;

void primCompile()
	compileWord();
end;

void primIsInt()
	Push(isInt()); //if hasnt returned then is an int
end;

void primConvertInt()
	//converts WORD_BUF to an int and pushes it	
	Push(convertInt());
end;

//////// Variables and constant auxiliaries (technical primitives) //////////
void createConstant()
	@char 9 name; //9 to pad a zero on the end
	convertName(scanWord(),name);   //produces an acceptable name
	int n = Pop(); 					 //n on stack
	editDictEntry(name,newByteCodeNode(PUSHLIT,n,0)); //creates a word
end;

void createVariable()
	@char 9 name; //9 to pad a zero on the end
	convertName(scanWord(),name);   //produces an acceptable name
	@int address = malloc(1); 					 //allocates memory
	editDictEntry(name,newByteCodeNode(PUSHLIT,address,0)); //creates a word
end;

void createTable()
	@char 9 name; //9 to pad a zero on the end
	convertName(scanWord(),name);   //produces an acceptable name
	@int address = malloc(Pop()); 					 //n on stack
	editDictEntry(name,newByteCodeNode(PUSHLIT,address,0)); //creates a word
end;

void dropAll()
	ForthStackPointer = 0;
end;

void comment()
	READ_IN_STATE = EMPTY;
end;