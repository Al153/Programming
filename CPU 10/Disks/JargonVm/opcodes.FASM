VARIABLE FORTHRET // address to return back to FORTH land

// define the parts of the data segments

DATASIZE CHAR[] STACK // contains the stack and heap. Stack grows up, heap grows down
STACK CONST HEAP // same area of memory
DATASIZE INT HpLimit
CFGSIZE CHAR[] CFG

// RUNTIME:

: sp, stp, ; // sp points to where the next spilled register stack value should go
: fp, jmp, ;
: temp, acc, ;
: acc, gp7, ; // use gp7 as an accumulator/spare value

: CELLS 4 * ; // ( n -- 4*n ) scales up indices to cell widths
: INSTRS 8 * ; // ( n -- 8*n ) scales up to register widths

// Stack Frame
	// *(fp+4) 	ret addr
	// *fp:		previous fp
	// *(fp-4) 	closure ->
	// *(fp-8) 	argument value

// Heap stuff

	// *obj TypeHeader
	// *(obj + 4n) info

: heapAllc // ( itemType -- ) pseudo op
	// TODO allocates heap space, puts in correct header
	// leaves value in acc
; 
: heapDllc ; // ( -- ) 		TODO

// Type definition
	: TYPE ; // defines a new type TODO
	: prim ; // needs to be scanned for GC TODO 
	: info ; // ignored by GC TODO
	: size ; // gives size of object for GC
	TYPE PAIR { prim , prim } // TODO: determine between prims and refs
	TYPE SUM { info , prim } // info field determines [Inl | Inr]: 11...1 : inr, 00...0: inl
	4294967295 CONST INR_id
	0 CONST INL_id
	TYPE REF { prim }
	TYPE CLOSURE { // Template. create closure types at compile time
		size ,
		info ,		// code pointer
		prim .. prim
	}

: defFn // ( -- ) reset stack maintenance words
	4, TopReg !
;

// Define how to manipulate the stack


N_SPACE STACKTLS
STACKTLS ->
	VARIABLE TopReg // points to next gp to put a stack value in
	0 TopReg !
	7 CONST topLimit // only use 7 regs for the stack


	// stack pointer should always point to the top of the stack that isn't in memory resides

	: dupFrame  // ( -- ) TODO: duplicate frame in registers to the stack
		temp, HpLimit ldi;
		temp, sp, 4 # cma[]; // need space for 4 registers, so check there is space
		fp, sp, 2 CELLS # ldi[]; // fp = sp + 2 * spaces
		3 ts, sp, STACK 0 CELLS + sti[];
		2 ts, sp, STACK 1 CELLS + sti[];
		1 ts, sp, STACK 2 CELLS + sti[];
		0 ts, sp, STACK 3 CELLS + sti[];
	;

	: flshRegs // ( -- ) TODO: flush regs representing the stack into memory
		
		// check there is space on the stack
		temp, HpLimit ldi; // load up the heap limit
		temp, sp, TopReg @ # cma[];
		less, 1 nskip;

		unc, STACK_OVERFLOW_ERROR bra;

		topreg @ while
			topreg --
			topreg @ stp STACK topreg @ CELLS + sti[];
		topreg @ loop
		stp, topreg @ CELLS # adda; // make stack space.
	; 
	: expand TopReg += TopReg @ topLimit < if else ." ERROR, top reg has got too high.\n" then ; // ( n -- ) Sets topreg to make space onthe stack. Assumes there is enough space

	: check // ( offset, calculated -- [ reg 0 | stackOffset 1 ])
		DUP
		topLimit < if
			0
		else
			topLimit - 1 // get original stackOffset
			// Now we need to bring more stack values into the registers

			Recentre
		then 
	;

	: pop // ( n -- )

		// TODO
		// pop n values from the stack
		DUP TopReg @ =< if
			TopReg -= // reduce the top reg pointer by n
		else
			TopReg @ - // otherwise, move values into the registers, and update the stack pointer
			0 TopReg !
			sp, SWAP CELLS # suba;		
		then
	;

	: pushr; // ( reg -- ) pseudo instr to move a register to the top of the stack, reg should be acc, zro, one etc
		// TODO
	; 
	

	: ts // ( offset -- reg ) gets the register for a particular stack offset
		// in any one instruction, one should get the register with the greatest offset first
		// this is in order to ensure that all stack values are in the registers first
		1 while
			DUP TopReg @ + check
		loop
	; EXPORT EXPORT EXPORT
;;
// Opcodes

: BPUSH // ( stack_item -- )
	acc, SWAP # ldi;
	acc, pushr;
; 
: BLOOKUPS // ( offset -- )
	acc, SWAP fp, SWAP, HEAP + ldi[];
	acc, pushr;
;  // lookup in stack with an offset
: BLOOKUPH // ( offset -- )
	// offset is offset in the closure
	acc, fp, STACK 4 - ldi[]; // get a pointer to our closure TODO: frame might be in memory or in regs..	

	temp, acc, HEAP ldi[]; // type check
	temp, closureHeader # suba;
	temp, testr, RUNTIME_TYPE_ERROR bra;

	2 + CELLS HEAP + // closure header + 2 fields (to bound var array)
	acc, SWAP acc, SWAP ldi[]; // pick the var
	acc, pushr;
;

: BUNARY  // ( unary_oper  -- )
	DUP U_NOT = if DROP
		0 ts, [ INPUT -> hex 7fffffff ;; ] # xora;
		 // we're using 31 bit ints since we need to distinguish between values and references for the GC to properly run
	else DUP U_NEG = if DROP
		0 ts, 1 # xora;
	else DUP U_READ = if DROP
		// TODO call a readint fn and write to 0 ts,
	else
		Throw an error // TODO
	then then then
;

: BOPER // ( oper -- ) 
	DUP O_AND = if DROP
		1 ts, 0 ts, andr;
		1 pop

	else DUP O_OR = if DROP
		1 ts, 0 ts, orrr;
		1 pop

	else DUP O_EQB = if DROP
		acc, [ INPUT -> hex ffffffff ;; ] ldi;
		1 ts, 0 ts, subr;
		1 ts, testr, 1 nskip;
			acc, [ INPUT -> hex ffffffff ;; ] ldi;
		acc, 1 ts, mov;
		1 pop

	else DUP O_EQI = if DROP
		acc, [ INPUT -> hex ffffffff ;; ] ldi;
		1 ts, 0 ts, subr;
		1 ts, testr, 1 nskip;
			acc, [ INPUT -> hex ffffffff ;; ] ldi;
		acc, 1 ts, mov;
		1 pop
		
	else DUP O_LT = if DROP
		acc, [ INPUT -> hex ffffffff ;; ] ldi;
		1 ts, 0 ts, cmp;
		les, 1 nskip;
			acc, [ INPUT -> hex ffffffff ;; ] ldi;
		acc, 1 ts, mov;
		1 pop

	else DUP U_ADD = if DROP
		1 ts, 0 ts, addr;
		1 ts, [ INPUT -> hex 80000000 ;; ] # orra; // account for top bit
		1 pop

	else DUP U_SUB = if DROP
		1 ts, 0 ts, subr;
		1 ts, [ INPUT -> hex 80000000 ;; ] # orra; // account for top bit
		1 pop

	else DUP U_MUL = if DROP
		1 ts, [ INPUT -> hex 7fffffff ;; ] # anda;
		0 ts, [ INPUT -> hex 7fffffff ;; ] # anda
		1 ts, 0 ts, mulr;
		1 ts, [ INPUT -> hex 80000000 ;; ] # orra; // account for top bit
		1 pop
	else
		Throw an error // TODO
	then then then
;
: BASSIGN //  ( -- )
	acc, 1 ts, HEAP ldi[]; // Typecheck for a ref
	acc, refHeader # suba;
	testr, RUNTIME_TYPE_ERROR bra;

	1 ts, 0 ts, SWAP HEAP 4 + sti[];	// do the assignment
;
: BSWAP  // ( -- )
	1 ts, 0 ts, SWAP  xorr;
	1 ts, 0 ts, xorr;
	1 ts, 0 ts, SWAP xorr;
;
: BPOP // ( -- )
	1 pop
; 

// Pair heap definition
//	Header (type val) - indicates that this is a pair
//	fst
//	snd

: BFST // ( -- )
	acc, 0 ts, HEAP ldi[];
	acc, pairHeader # suba; // TODO: define the pair header
	acc, testr RUNTIME_TYPE_ERROR bra; //TODO: define the runtime type error
	0 ts, 0 ts, HEAP 4 + ldi[]; // load up from the  first part of the index
;
: BSND // ( -- )
	acc, 0 ts, HEAP ldi[];
	acc, pairHeader # suba; // TODO: define the pair header
	acc, testr RUNTIME_TYPE_ERROR bra; //TODO: define the runtime type error
	0 ts, 0 ts, HEAP 8 + ldi[]; // load up from the second part of the index
;
: BDEREF  // ( -- )
	acc, 0 ts, HEAP ldi[];
	acc, refHeader # suba; // TODO: define the pair header
	acc, testr RUNTIME_TYPE_ERROR bra; //TODO: define the runtime type error
	0 ts, 0 ts, HEAP 4 + ldi[]; // load up from the  first part of the index
;
: BAPPLY // ( -- )
	acc, 0 ts, HEAP ldi[]; // check for a closure
	acc, closureHeader # subi;
	acc testr, RUNTIME_TYPE_ERROR bra;

	// Stack Frame
	// *(fp+4) 	ret addr
	// *fp:		previous fp
	// *(fp-4) 	closure ->
	// *(fp-8) 	argument value

	// Stack: ( frame ... val closure -- frame ... frame val )

	// save closure and val
	1 ts, acc, mov; // val
	0 ts, temp, mov; // closure

	2 pop


	// First, push all stack items in registers to memory
	{ STACKTLS -> }
		flshRegs
		4 expand
	{ ;; }

	// construct frame
	acc, 3 ts, mov;
	temp, 2 ts, mov;
	fp, 1 ts, mov;
	0 ts, pc, OFFSET # ldi[]; // get return address TODO
	{ STACKTLS -> }
				 // 7 instrs
		dupFrame // duplicate frame into memory, set new fp
	{ ;; }
	fp, sp, OFFSET # ldi[]; // new frame pointer is derived from stack pointer with TODO offset
;

: BRETURN  //  ( -- )
	2 ts, fp, mov; // get old frame
	1 ts, temp, mov; // store return addr
	0 ts, acc, mov; // store return value

	5 pop // remove stack frame (return value, return addr, frame addr, closure, and argument)
	acc, pushr;
	{ STACKTLS } -> Recentre { ;; } // TODO: centres top of stack to be halfway in the registers
	temp, pc, mov; // jump
;

: BMK_PAIR  //  ( -- )
	PAIR heapAllc // allocate a heap object into acc
	1 ts, acc, HEAP 4 + sti[]; // fst element
	0 ts, acc, HEAP 8 + sti[]; // snd element
	acc, 1 ts mov;
	1 pop
;

: BMK_INL // ( -- )
	SUM heapAllc // allocates a correct heap object into acc
	temp, INL_id # ldi; // indicates that this is an INL
	temp, acc, HEAP 4 + sti[]; // store the marker
	0 ts, acc HEAP 8 + sti[]; // store value
	acc, 0 ts mov; // "push" the reference
; 
: BMK_INR // ( -- )
	SUM heapAllc // allocates a correct heap object into acc
	temp, INL_id # ldi; // indicates that this is an INR
	temp, acc, HEAP 4 + sti[]; // store the marker
	0 ts, acc HEAP 8 + sti[]; // store value
	acc, 0 ts mov; // "push" the reference
;
: BMK_REF //  ( -- )
	REF heapAllc // create a stack reference
	0 ts, acc, HEAP 4 + sti[]; // store TOS to i
	acc, 0 ts, mov; 		// "Push" the reference
; 
: BMK_CLOSURE //  ( location length -- ) 
	// int is closure

; 
: BTEST //    ( location -- )
	0 ts,
	1 pop
	testr, SWAP bra;
;
: BCASE  //  ( location-- )
	acc, 0 ts, HEAP ldi[];
	acc, SUMHeader # suba; 
	acc, testr, RUNTIME_TYPE_ERROR bra;
	
	acc, 0 ts, HEAP 8 + ldi[]; // load the value
	acc pushr; // put it onto stack // TODO: do we need to apply or something?

	acc, 1 ts, HEAP 4 + ldi[]; // get the marker
	acc, testr SWAP bra; // if an INR, then goto the label

;
: BGOTO
	unc, SWAP bra;
; //  ( location -- ) call a function
: BLABEL // ( labelVar -- ) - labels should be pre declared
	!LABEL
;
: BHALT // return to forth world, print out result too
	0 ts, odr;
	unc, FORTHRET @ bra;
; 
