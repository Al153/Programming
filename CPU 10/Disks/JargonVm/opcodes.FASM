
// Opcodes

: BPUSH // ( stack_item -- )
	acc, SWAP # ldi;
	acc, pushr;
; 
: BLOOKUPS // ( offset -- )
	acc, SWAP fp, SWAP, STACK + ldi[];
	acc, pushr;
;  // lookup in stack with an offset

: BLOOKUPH // ( offset -- )
	// offset is offset in the closure
	acc, fp, STACK 4 - ldi[]; // get a pointer to our closure
	acc, acc, HEAPREG ldi[]; // get the reference into the heap from the Heap registry

	closureHeader typeChk;

	ClsHpPos // get particular bound var out of closure
	acc, SWAP acc, SWAP ldi[]; // pick the var
	acc, pushr;
;

: BUNARY  // ( unary_oper  -- )
	DUP U_NOT = if DROP
		0 ts, [ INPUT -> hex 7fffffff ;; ] # xora;
		 // we're using 31 bit ints since we need to distinguish between values and references for the GC to properly run
	else DUP U_NEG = if DROP
		0 ts, 1 # xora;
	else DUP U_READ = if DROP
		// TODO call a readint fn and write to 0 ts,
	else
		Throw an error // TODO
	then then then
;

: BOPER // ( oper -- ) 
	DUP O_AND = if DROP
		1 ts, 0 ts, andr;
		1 pop

	else DUP O_OR = if DROP
		1 ts, 0 ts, orrr;
		1 pop

	else DUP O_EQB = if DROP
		acc, [ INPUT -> hex ffffffff ;; ] ldi;
		1 ts, 0 ts, subr;
		1 ts, testr, 1 nskip;
			acc, [ INPUT -> hex ffffffff ;; ] ldi;
		acc, 1 ts, mov;
		1 pop

	else DUP O_EQI = if DROP
		acc, [ INPUT -> hex ffffffff ;; ] ldi;
		1 ts, 0 ts, subr;
		1 ts, testr, 1 nskip;
			acc, [ INPUT -> hex ffffffff ;; ] ldi;
		acc, 1 ts, mov;
		1 pop
		
	else DUP O_LT = if DROP
		acc, [ INPUT -> hex ffffffff ;; ] ldi;
		1 ts, 0 ts, cmp;
		les, 1 nskip;
			acc, [ INPUT -> hex ffffffff ;; ] ldi;
		acc, 1 ts, mov;
		1 pop

	else DUP U_ADD = if DROP
		1 ts, 0 ts, addr;
		1 ts, [ INPUT -> hex 80000000 ;; ] # orra; // account for top bit
		1 pop

	else DUP U_SUB = if DROP
		1 ts, 0 ts, subr;
		1 ts, [ INPUT -> hex 80000000 ;; ] # orra; // account for top bit
		1 pop

	else DUP U_MUL = if DROP
		1 ts, [ INPUT -> hex 7fffffff ;; ] # anda;
		0 ts, [ INPUT -> hex 7fffffff ;; ] # anda
		1 ts, 0 ts, mulr;
		1 ts, [ INPUT -> hex 80000000 ;; ] # orra; // account for top bit
		1 pop
	else
		Throw an error // TODO
	then then then
;
: BASSIGN //  ( -- )
	acc, 1 ts, HEAPREG ldi[]; // get pointer to ref from the heap registry

	refHeader typeChk;

	acc, 0 ts, SWAP HEAP 1 CELLS + sti[];	// do the assignment

	2 pop
;
: BSWAP  // ( -- )
	1 ts, 0 ts, SWAP  xorr;
	1 ts, 0 ts, xorr;
	1 ts, 0 ts, SWAP xorr;
;
: BPOP // ( -- )
	1 pop
; 

// Pair heap definition
//	Header (type val) - indicates that this is a pair
//	fst
//	snd

: BFST // ( -- )
	acc, 0 ts, HEAPREG ldi[];
	
	pairHeader typeChk; // TODO: define the pair header

	0 ts, acc, HEAP 1 CELLS + ldi[]; // load up from the  first part of the index
;
: BSND // ( -- )
	acc, 0 ts, HEAPREG ldi[];

	pairHeader typeChk; // TODO: define the pair header


	0 ts, acc, HEAP 2 CELLS + ldi[]; // load up from the  first part of the index
;
: BDEREF  // ( -- )
	acc, 0 ts, HEAPREG  ldi[];

	refHeader typeChk; // TODO: define the pair header

	0 ts, acc, HEAP 1 CELLS + ldi[]; // load up from the  first part of the index
;
: BAPPLY // ( -- )
	acc, 0 ts, HEAPREG ldi[]; // check for a closure

	closureHeader typeChk;


	// Stack Frame
	// *(fp+4) 	ret addr
	// *fp:		previous fp
	// *(fp-4) 	closure ->
	// *(fp-8) 	argument value

	// Stack: ( frame ... val closure -- frame ... frame val )

	// save closure and val
	1 ts, acc, mov; // val
	0 ts, temp, mov; // closure

	2 pop


	// First, push all stack items in registers to memory
	{ STACKTLS -> }
		flshRegs
		4 expand
	{ ;; }

	// construct frame
	acc, 3 ts, mov;
	temp, 2 ts, mov;
	fp, 1 ts, mov;
	0 ts, pc, OFFSET # ldi[]; // get return address TODO
	{ STACKTLS -> }
				 // 7 instrs
		dupFrame // duplicate frame into memory, set new fp
	{ ;; }

	temp, sp, STACK 2 CELLS + ldi[]; // recover closure reference from the stack
	temp, temp, HEAPREG ldi[]; // dereference via HEAPREG
	pc, temp, HEAP 2 CELLS + ldi[]; // do the jump 

	restStck
;

: BRETURN  //  ( -- )
	2 ts, fp, mov; // get old frame
	1 ts, temp, mov; // store return addr
	0 ts, acc, mov; // store return value

	5 pop // remove stack frame (return value, return addr, frame addr, closure, and argument)
	acc, pushr;
	{ STACKTLS } -> 4 Recentre { ;; } // TODO: centres top of stack to be halfway in the registers
	temp, pc, mov; // jump
;

: BMK_PAIR  //  ( -- )
	PAIR heapAllc // allocate a heap object into acc
	1 ts, temp, HEAP 1 CELLS + sti[]; // fst element
	0 ts, temp, HEAP 2 CELLS + sti[]; // snd element
	acc, 1 ts mov;
	1 pop
;

: BMK_INL // ( -- )
	SUM heapAllc // allocates a correct HeapReg pointer into acc, Heap pointer into temp
	0 ts, temp, HEAP 2 CELLS + sti[]; // store value

	0 ts, INL_id # ldi; // indicates that this is an INL
	temp, temp, HEAP 1 CELLS + sti[]; // store the marker
	
	acc, 0 ts mov; // "push" the reference
; 
: BMK_INR // ( -- )
	SUM heapAllc // allocates a correct heap object into acc
	0 ts, temp, HEAP 2 CELLS + sti[]; // store value
	
	0 ts, INR_id # ldi; // indicates that this is an INR
	temp, temp, HEAP 1 CELLS + sti[]; // store the marker
	
	acc, 0 ts mov; // "push" the reference
; 
: BMK_REF //  ( -- )
	REF heapAllc // create a stack reference
	0 ts, temp, HEAP 1 CELLS + sti[]; // store TOS to i
	acc, 0 ts, mov; 		// "Push" the reference
;

0 INT PTRSTOR
: BMK_CLOSURE //  ( location length -- ) 
	// length is closure argument length
	// location is place to jump to for execution
	// need to pop length items into the closure a run time .. complicated
	// TODO define CLOSURE to return an n_closure header when called
	DUP CLOSURE heapAllc // acc = heapreg addr, temp = clo
	acc, PTRSTOR sti; // save acc in O(1) space in data -- can't guarantee any spare registers so have to use this variable
	
	SWAP acc, SWAP # ldi;
	acc, temp, HEAP 2 CELLS + sti[]; // store the jump location to the header 

	acc, closureHeader # ldi;
	acc, temp, HEAP 0 CELLS + sti[];

	acc, OVER, # ldi;
	acc, temnp, HEAP 1 CELLS + sti[];

	DUP
	DUP while
		1 - 
		DUP CLSR_PSH // pops n'th value into closure
	DUP loop
	DROP pop // pop n from stack

	acc, PTRSTOR ldi; // restore acc
	acc, pushr; // push it
;

: BTEST //    ( location -- )
	0 ts,
	1 pop
	testr, SWAP bra;
;
: BCASE  //  ( location-- )
	acc, 0 ts, HEAPREG ldi[];

	SUMHeader typeChk;

	temp, acc, HEAP 2 CELLS + ldi[]; // load the value
	temp, pushr; // put it onto stack

	acc, acc, HEAP 1 CELLS + ldi[]; // get the marker
	acc, testr SWAP bra; // if an INR, then goto the label, otherwise stay here
;
: BGOTO
	unc, SWAP bra;
; //  ( location -- ) call a function
: BLABEL // ( labelVar -- ) - labels should be pre declared
	!LABEL
;
: BHALT // return to forth world, print out result too
	0 ts, odr;
	unc, FORTHRET @ bra;
; 
