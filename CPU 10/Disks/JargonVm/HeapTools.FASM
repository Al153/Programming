N_SPACE HeapSetp
HeapSetp -> 
	: setCells DUP 2 CELLS + ! ; // ( n -- ) adds in a link between adjacent cells
	: lessLmt HpRLimit 1 - 2 * CELLS < ; // ( n -- bool ) checks that n < 2*(HpRLimit - 1)

	: initHeap // ( -- topOfHeapReg )
		0 DUP lessLmt while
			DUP setCells
			2 CELLS +
		DUP lessLmt loop 
	;

	initHeap INT TopHeap EXPORT

	: nextHR; // ( rTemp r1  -- )
	// pseudo op, gets next Heap Reg entry from the registry
		OVER OVER DUP TopHeap ldi;	// (r1, TopHeap ldi;)
		testr, 1 nskip; // ( r1, testr, 1 nskip;)
		unc, RUN_OUT_OF_HEAP_REG_SPACE_EXCEPTION bra; // TODO: where does this go?
		HEAPREG 1 CELLS + ldi[]; // (rTemp, r1, HEAPREG 1 CELLS + ldi[];)
 		TopHeap sti; // (rTemp, TopHeap sti;)
	; 

	 : PushHR;
	 // ( rTemp r1  -- ) pseudo op, gets next Heap Reg entry from the
		OVER, TopHeap ldi;	// (rTemp, TopHeap ldi;)
		SWAP OVER HEAPREG 1 CELLS + ldi[]; // (rTemp, r1, HEAPREG 1 CELLS + ldi[];)
 		TopHeap sti; // (r1, TopHeap sti;)
	; 
;;

: heapAllc // ( itemType -- ) pseudo op
	// TODO allocates heap space, puts in correct header
	// leaves HeapReg pointer in acc, leaves actual heap instance in temp,
	// TODO dereferencing should dereference twice
	
	// Assumption: heap is full up to the TopHeap pointer
	// So steps are:
	// 	- find out size of object
	// 	- increment top cheap and check it's within size
	// 	- store header
	// 	- create instance in

	// allocation is reasonably easy
	{ TYPE -> } DUP DUP @size SWAP @offset 1 + + CELLS { ;; } // get size to allocate
	temp, acc, nextHR; // get a heap reg entry

	temp, RegEntry sti;	// store this for now to free up a register
	
	acc, HpLimit ldi; // get top of heap
	acc, OVER # suba; // increment top of heap to the end of our object
	
	acc, sp, cmr; // check whether we've used up the heap space
	les, HEAP_OVERFLOW bra;

	temp, SWAP @header # ldi; // get hold of the type's header
	temp, acc, HEAP sti[]; // store the header int othe heap object

	temp, RegEntry ldi; // restore the HeapReg reference
	acc, temp, HeapReg sti[];  // register the object
;
: heapDllc  // ( reg -- )
	// Dealloc object in r1
;


LABEL: GC_RUN
	// store all 8 regs
	// TODO

	 // Linked lists over second field of HeapReg entries
	0 INT BLACK // no links to white set
	0 INT GREY // To be processed
	0 INT WHITE // condemned set
	
	// TODO
	// STEPS:
		// Traverse stack - split into frame items and regular stack entries
			// add references into the grey list

		// for element in the grey list: - how do we know when done?
			//  go to its links
			//  For each link:
				// check if in the Grey or black lists - how?
				// if not in Grey or black, add to end of grey list

		// then we want to sort by starting address to do a compaction




	// TODO: restore all 8 regs